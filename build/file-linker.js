'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

require('source-map-support/register');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nodeUtils = require('node-utils');

var _fsUtils = require('./fs-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { genEveryNull } = _nodeUtils.arrayAsync;

const { lstat, mkdirp, unlink, dirIsEmpty, rmdir } = _nodeUtils.fsAsync;
const { gen, genAllNull } = _nodeUtils.genAwait;

const MODULE_SEPERATOR = '/';

async function isSymbolicLink(modulePath) {
  const [err, stat] = await gen(lstat(modulePath));

  if (err || !stat) return false;

  return stat.isSymbolicLink();
}

let FileLinker = class FileLinker {

  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.nodeModulesPath = _path2.default.resolve(projectRoot, 'node_modules');
  }

  async canAdd(moduleName, modulePath) {
    const linkPath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const [stats, currentTarget] = await genAllNull(lstat(linkPath), (0, _fsUtils.readSymlinkTarget)(linkPath));

    if (stats && !stats.isSymbolicLink()) {
      return `${moduleName} already exists and is not a symlink`;
    }

    if (currentTarget && currentTarget !== modulePath) {
      return `${moduleName} is already linked to ${currentTarget}`;
    }

    const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
    if (moduleContainsFolders) {
      const moduleParts = moduleName.split(MODULE_SEPERATOR);
      const folderParts = moduleParts.slice(0, -1);

      const allPartsAreFolders = await genEveryNull(folderParts, async (current, index) => {
        const folders = folderParts.slice(0, index + 1);
        const folderPath = _path2.default.resolve(this.nodeModulesPath, ...folders);
        const [folderExists, folderStats] = await genAllNull((0, _fsUtils.exists)(folderPath), lstat(folderPath));

        if (!folderExists || folderStats && folderStats.isDirectory()) return true;

        return false;
      }, '');

      if (!allPartsAreFolders) {
        return `Some parts of ${moduleName} already exist and are not directories`;
      }
    }

    return true;
  }

  async canRemove(moduleName) {
    const modulePath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const [fileExists, isSymLink] = await genAllNull((0, _fsUtils.exists)(modulePath), isSymbolicLink(modulePath));
    return !fileExists || !!isSymLink;
  }

  async add(moduleName, modulePath) {
    const linkPath = _path2.default.resolve(this.nodeModulesPath, `${moduleName}.js`);
    let linkRoot = this.nodeModulesPath;
    const [canAdd, existingTarget] = await genAllNull(this.canAdd(moduleName, modulePath), (0, _fsUtils.readSymlinkTarget)(linkPath));

    if (existingTarget && existingTarget === modulePath) return;
    if (!canAdd) {
      throw new Error(`can not link module ${moduleName} to ${modulePath}`);
    }

    const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
    if (moduleContainsFolders) {
      const moduleParts = moduleName.split(MODULE_SEPERATOR);
      const folderParts = moduleParts.slice(0, -1);
      const folder = _path2.default.resolve(this.nodeModulesPath, ...folderParts);

      await mkdirp(folder);

      linkRoot = folder;
    }

    const relModulePath = _path2.default.relative(linkRoot, modulePath);

    await (0, _fsUtils.linkFile)(relModulePath, linkPath);
  }

  async removeModule(moduleName) {
    const canRemoveModule = await this.canRemove(moduleName);

    if (!canRemoveModule) {
      throw new Error(`can not unlink module ${moduleName}`);
    }

    const linkPath = _path2.default.resolve(this.nodeModulesPath, `${moduleName}.js`);
    const fileExists = await (0, _fsUtils.exists)(linkPath);

    if (fileExists) {
      await unlink(linkPath);

      const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
      if (moduleContainsFolders) {
        const moduleParts = moduleName.split(MODULE_SEPERATOR);
        const folderParts = moduleParts.slice(0, -1);

        for (let i = folderParts.length - 1; i >= 0; i--) {
          const dirPath = _path2.default.resolve(this.nodeModulesPath, ...folderParts.slice(0, i + 1));
          const isEmpty = await dirIsEmpty(dirPath);

          if (isEmpty) {
            await rmdir(dirPath);
          }
        }
      }
    }
  }
};
exports.default = FileLinker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWxpbmtlci5qcyJdLCJuYW1lcyI6WyJnZW5FdmVyeU51bGwiLCJsc3RhdCIsIm1rZGlycCIsInVubGluayIsImRpcklzRW1wdHkiLCJybWRpciIsImdlbiIsImdlbkFsbE51bGwiLCJNT0RVTEVfU0VQRVJBVE9SIiwiaXNTeW1ib2xpY0xpbmsiLCJtb2R1bGVQYXRoIiwiZXJyIiwic3RhdCIsIkZpbGVMaW5rZXIiLCJjb25zdHJ1Y3RvciIsInByb2plY3RSb290Iiwibm9kZU1vZHVsZXNQYXRoIiwicmVzb2x2ZSIsImNhbkFkZCIsIm1vZHVsZU5hbWUiLCJsaW5rUGF0aCIsInN0YXRzIiwiY3VycmVudFRhcmdldCIsIm1vZHVsZUNvbnRhaW5zRm9sZGVycyIsImluZGV4T2YiLCJtb2R1bGVQYXJ0cyIsInNwbGl0IiwiZm9sZGVyUGFydHMiLCJzbGljZSIsImFsbFBhcnRzQXJlRm9sZGVycyIsImN1cnJlbnQiLCJpbmRleCIsImZvbGRlcnMiLCJmb2xkZXJQYXRoIiwiZm9sZGVyRXhpc3RzIiwiZm9sZGVyU3RhdHMiLCJpc0RpcmVjdG9yeSIsImNhblJlbW92ZSIsImZpbGVFeGlzdHMiLCJpc1N5bUxpbmsiLCJhZGQiLCJsaW5rUm9vdCIsImV4aXN0aW5nVGFyZ2V0IiwiRXJyb3IiLCJmb2xkZXIiLCJyZWxNb2R1bGVQYXRoIiwicmVsYXRpdmUiLCJyZW1vdmVNb2R1bGUiLCJjYW5SZW1vdmVNb2R1bGUiLCJpIiwibGVuZ3RoIiwiZGlyUGF0aCIsImlzRW1wdHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFLQSxNQUFNLEVBQUVBLFlBQUYsMEJBQU47O0FBQ0EsTUFBTSxFQUFFQyxLQUFGLEVBQVNDLE1BQVQsRUFBaUJDLE1BQWpCLEVBQXlCQyxVQUF6QixFQUFxQ0MsS0FBckMsdUJBQU47QUFDQSxNQUFNLEVBQUVDLEdBQUYsRUFBT0MsVUFBUCx3QkFBTjs7QUFFQSxNQUFNQyxtQkFBbUIsR0FB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LFVBQU1DLFdBQVcsZUFBS0gsT0FBTCxDQUFhLEtBQUtELGVBQWxCLEVBQW9DLEdBQUVHLFVBQVcsS0FBakQsQ0FBakI7QUFDQSxVQUFNbUIsYUFBYSxNQUFNLHFCQUFPbEIsUUFBUCxDQUF6Qjs7QUFFQSxRQUFJa0IsVUFBSixFQUFnQjtBQUNkLFlBQU1uQyxPQUFPaUIsUUFBUCxDQUFOOztBQUVBLFlBQU1HLHdCQUF3QkosV0FBV0ssT0FBWCxDQUFtQmhCLGdCQUFuQixLQUF3QyxDQUF0RTtBQUNBLFVBQUllLHFCQUFKLEVBQTJCO0FBQ3pCLGNBQU1FLGNBQWNOLFdBQVdPLEtBQVgsQ0FBaUJsQixnQkFBakIsQ0FBcEI7QUFDQSxjQUFNbUIsY0FBY0YsWUFBWUcsS0FBWixDQUFrQixDQUFsQixFQUFxQixDQUFDLENBQXRCLENBQXBCOztBQUVBLGFBQUssSUFBSXFCLElBQUl0QixZQUFZdUIsTUFBWixHQUFxQixDQUFsQyxFQUFxQ0QsS0FBSyxDQUExQyxFQUE2Q0EsR0FBN0MsRUFBa0Q7QUFDaEQsZ0JBQU1FLFVBQVUsZUFBS2xDLE9BQUwsQ0FBYSxLQUFLRCxlQUFsQixFQUFtQyxHQUFHVyxZQUFZQyxLQUFaLENBQWtCLENBQWxCLEVBQXFCcUIsSUFBSSxDQUF6QixDQUF0QyxDQUFoQjtBQUNBLGdCQUFNRyxVQUFVLE1BQU1oRCxXQUFXK0MsT0FBWCxDQUF0Qjs7QUFFQSxjQUFJQyxPQUFKLEVBQWE7QUFDWCxrQkFBTS9DLE1BQU04QyxPQUFOLENBQU47QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBNUdtRCxDO2tCQUFqQ3RDLFUiLCJmaWxlIjoiZmlsZS1saW5rZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgYXJyYXlBc3luYywgZnNBc3luYywgZ2VuQXdhaXQgfSBmcm9tICdub2RlLXV0aWxzJztcbmltcG9ydCB7IGV4aXN0cywgbGlua0ZpbGUsIHJlYWRTeW1saW5rVGFyZ2V0IH0gZnJvbSAnLi9mcy11dGlscyc7XG5cbmltcG9ydCB0eXBlIHsgSU1vZHVsZU1hcCB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgdHlwZSB7IHRBYnNvbHV0ZVBhdGgsIHRNb2R1bGVOYW1lIH0gZnJvbSAnZmxvdy10eXBlcyc7XG5cbmNvbnN0IHsgZ2VuRXZlcnlOdWxsIH0gPSBhcnJheUFzeW5jO1xuY29uc3QgeyBsc3RhdCwgbWtkaXJwLCB1bmxpbmssIGRpcklzRW1wdHksIHJtZGlyIH0gPSBmc0FzeW5jO1xuY29uc3QgeyBnZW4sIGdlbkFsbE51bGwgfSA9IGdlbkF3YWl0O1xuXG5jb25zdCBNT0RVTEVfU0VQRVJBVE9SID0gJy8nO1xuXG5hc3luYyBmdW5jdGlvbiBpc1N5bWJvbGljTGluayhtb2R1bGVQYXRoOiB0QWJzb2x1dGVQYXRoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IFtlcnIsIHN0YXRdID0gYXdhaXQgZ2VuKGxzdGF0KG1vZHVsZVBhdGgpKTtcblxuICBpZiAoZXJyIHx8ICFzdGF0KSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHN0YXQuaXNTeW1ib2xpY0xpbmsoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUxpbmtlciBpbXBsZW1lbnRzIElNb2R1bGVNYXAge1xuICBwcm9qZWN0Um9vdDogdEFic29sdXRlUGF0aDtcbiAgbm9kZU1vZHVsZXNQYXRoOiB0QWJzb2x1dGVQYXRoO1xuXG4gIGNvbnN0cnVjdG9yKHByb2plY3RSb290OiB0QWJzb2x1dGVQYXRoKSB7XG4gICAgdGhpcy5wcm9qZWN0Um9vdCA9IHByb2plY3RSb290O1xuICAgIHRoaXMubm9kZU1vZHVsZXNQYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RSb290LCAnbm9kZV9tb2R1bGVzJyk7XG4gIH1cblxuICBhc3luYyBjYW5BZGQobW9kdWxlTmFtZTogdE1vZHVsZU5hbWUsIG1vZHVsZVBhdGg6IHRBYnNvbHV0ZVBhdGgpOiBQcm9taXNlPHRydWUgfCBzdHJpbmc+IHtcbiAgICBjb25zdCBsaW5rUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgbW9kdWxlTmFtZSk7XG4gICAgY29uc3QgW3N0YXRzLCBjdXJyZW50VGFyZ2V0XSA9IGF3YWl0IGdlbkFsbE51bGwobHN0YXQobGlua1BhdGgpLCByZWFkU3ltbGlua1RhcmdldChsaW5rUGF0aCkpO1xuXG4gICAgaWYgKHN0YXRzICYmICFzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICByZXR1cm4gYCR7bW9kdWxlTmFtZX0gYWxyZWFkeSBleGlzdHMgYW5kIGlzIG5vdCBhIHN5bWxpbmtgO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIGN1cnJlbnRUYXJnZXQgIT09IG1vZHVsZVBhdGgpIHtcbiAgICAgIHJldHVybiBgJHttb2R1bGVOYW1lfSBpcyBhbHJlYWR5IGxpbmtlZCB0byAke2N1cnJlbnRUYXJnZXR9YDtcbiAgICB9XG5cbiAgICBjb25zdCBtb2R1bGVDb250YWluc0ZvbGRlcnMgPSBtb2R1bGVOYW1lLmluZGV4T2YoTU9EVUxFX1NFUEVSQVRPUikgPj0gMDtcbiAgICBpZiAobW9kdWxlQ29udGFpbnNGb2xkZXJzKSB7XG4gICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IG1vZHVsZU5hbWUuc3BsaXQoTU9EVUxFX1NFUEVSQVRPUik7XG4gICAgICBjb25zdCBmb2xkZXJQYXJ0cyA9IG1vZHVsZVBhcnRzLnNsaWNlKDAsIC0xKTtcblxuICAgICAgY29uc3QgYWxsUGFydHNBcmVGb2xkZXJzID0gYXdhaXQgZ2VuRXZlcnlOdWxsKFxuICAgICAgICBmb2xkZXJQYXJ0cyxcbiAgICAgICAgYXN5bmMgKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9sZGVycyA9IGZvbGRlclBhcnRzLnNsaWNlKDAsIGluZGV4ICsgMSk7XG4gICAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgLi4uZm9sZGVycyk7XG4gICAgICAgICAgY29uc3QgW2ZvbGRlckV4aXN0cywgZm9sZGVyU3RhdHNdID0gYXdhaXQgZ2VuQWxsTnVsbChleGlzdHMoZm9sZGVyUGF0aCksIGxzdGF0KGZvbGRlclBhdGgpKTtcblxuICAgICAgICAgIGlmICghZm9sZGVyRXhpc3RzIHx8IChmb2xkZXJTdGF0cyAmJiBmb2xkZXJTdGF0cy5pc0RpcmVjdG9yeSgpKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgICcnLFxuICAgICAgKTtcblxuICAgICAgaWYgKCFhbGxQYXJ0c0FyZUZvbGRlcnMpIHtcbiAgICAgICAgcmV0dXJuIGBTb21lIHBhcnRzIG9mICR7bW9kdWxlTmFtZX0gYWxyZWFkeSBleGlzdCBhbmQgYXJlIG5vdCBkaXJlY3Rvcmllc2A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBjYW5SZW1vdmUobW9kdWxlTmFtZTogdE1vZHVsZU5hbWUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBtb2R1bGVQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMubm9kZU1vZHVsZXNQYXRoLCBtb2R1bGVOYW1lKTtcbiAgICBjb25zdCBbZmlsZUV4aXN0cywgaXNTeW1MaW5rXSA9IGF3YWl0IGdlbkFsbE51bGwoZXhpc3RzKG1vZHVsZVBhdGgpLCBpc1N5bWJvbGljTGluayhtb2R1bGVQYXRoKSk7XG4gICAgcmV0dXJuICFmaWxlRXhpc3RzIHx8ICEhaXNTeW1MaW5rO1xuICB9XG5cbiAgYXN5bmMgYWRkKG1vZHVsZU5hbWU6IHRNb2R1bGVOYW1lLCBtb2R1bGVQYXRoOiB0QWJzb2x1dGVQYXRoKSB7XG4gICAgY29uc3QgbGlua1BhdGggPSBwYXRoLnJlc29sdmUodGhpcy5ub2RlTW9kdWxlc1BhdGgsIGAke21vZHVsZU5hbWV9LmpzYCk7XG4gICAgbGV0IGxpbmtSb290ID0gdGhpcy5ub2RlTW9kdWxlc1BhdGg7XG4gICAgY29uc3QgW2NhbkFkZCwgZXhpc3RpbmdUYXJnZXRdID0gYXdhaXQgZ2VuQWxsTnVsbCh0aGlzLmNhbkFkZChtb2R1bGVOYW1lLCBtb2R1bGVQYXRoKSwgcmVhZFN5bWxpbmtUYXJnZXQobGlua1BhdGgpKTtcblxuICAgIGlmIChleGlzdGluZ1RhcmdldCAmJiBleGlzdGluZ1RhcmdldCA9PT0gbW9kdWxlUGF0aCkgcmV0dXJuO1xuICAgIGlmICghY2FuQWRkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbiBub3QgbGluayBtb2R1bGUgJHttb2R1bGVOYW1lfSB0byAke21vZHVsZVBhdGh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kdWxlQ29udGFpbnNGb2xkZXJzID0gbW9kdWxlTmFtZS5pbmRleE9mKE1PRFVMRV9TRVBFUkFUT1IpID49IDA7XG4gICAgaWYgKG1vZHVsZUNvbnRhaW5zRm9sZGVycykge1xuICAgICAgY29uc3QgbW9kdWxlUGFydHMgPSBtb2R1bGVOYW1lLnNwbGl0KE1PRFVMRV9TRVBFUkFUT1IpO1xuICAgICAgY29uc3QgZm9sZGVyUGFydHMgPSBtb2R1bGVQYXJ0cy5zbGljZSgwLCAtMSk7XG4gICAgICBjb25zdCBmb2xkZXIgPSBwYXRoLnJlc29sdmUodGhpcy5ub2RlTW9kdWxlc1BhdGgsIC4uLmZvbGRlclBhcnRzKTtcblxuICAgICAgYXdhaXQgbWtkaXJwKGZvbGRlcik7XG5cbiAgICAgIGxpbmtSb290ID0gZm9sZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbE1vZHVsZVBhdGggPSBwYXRoLnJlbGF0aXZlKGxpbmtSb290LCBtb2R1bGVQYXRoKTtcblxuICAgIGF3YWl0IGxpbmtGaWxlKHJlbE1vZHVsZVBhdGgsIGxpbmtQYXRoKTtcbiAgfVxuXG4gIGFzeW5jIHJlbW92ZU1vZHVsZShtb2R1bGVOYW1lOiB0TW9kdWxlTmFtZSkge1xuICAgIGNvbnN0IGNhblJlbW92ZU1vZHVsZSA9IGF3YWl0IHRoaXMuY2FuUmVtb3ZlKG1vZHVsZU5hbWUpO1xuXG4gICAgaWYgKCFjYW5SZW1vdmVNb2R1bGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2FuIG5vdCB1bmxpbmsgbW9kdWxlICR7bW9kdWxlTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5rUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgYCR7bW9kdWxlTmFtZX0uanNgKTtcbiAgICBjb25zdCBmaWxlRXhpc3RzID0gYXdhaXQgZXhpc3RzKGxpbmtQYXRoKTtcblxuICAgIGlmIChmaWxlRXhpc3RzKSB7XG4gICAgICBhd2FpdCB1bmxpbmsobGlua1BhdGgpO1xuXG4gICAgICBjb25zdCBtb2R1bGVDb250YWluc0ZvbGRlcnMgPSBtb2R1bGVOYW1lLmluZGV4T2YoTU9EVUxFX1NFUEVSQVRPUikgPj0gMDtcbiAgICAgIGlmIChtb2R1bGVDb250YWluc0ZvbGRlcnMpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlUGFydHMgPSBtb2R1bGVOYW1lLnNwbGl0KE1PRFVMRV9TRVBFUkFUT1IpO1xuICAgICAgICBjb25zdCBmb2xkZXJQYXJ0cyA9IG1vZHVsZVBhcnRzLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gZm9sZGVyUGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBkaXJQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMubm9kZU1vZHVsZXNQYXRoLCAuLi5mb2xkZXJQYXJ0cy5zbGljZSgwLCBpICsgMSkpO1xuICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBhd2FpdCBkaXJJc0VtcHR5KGRpclBhdGgpO1xuXG4gICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHJtZGlyKGRpclBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19