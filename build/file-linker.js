'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

require('source-map-support/register');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _nodeUtils = require('node-utils');

var _fsUtils = require('./fs-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { every: everyAsync } = _nodeUtils.arrayAsync;

const { lstat, mkdirp, unlink, dirIsEmpty, rmdir } = _nodeUtils.fsAsync;
const { gen, genAllNull } = _nodeUtils.genAwait;

const MODULE_SEPERATOR = '/';

async function isSymbolicLink(modulePath) {
  const [err, stat] = await gen(lstat(modulePath));

  if (err || !stat) return false;

  return stat.isSymbolicLink();
}

let FileLinker = class FileLinker {

  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.nodeModulesPath = _path2.default.resolve(projectRoot, 'node_modules');
  }

  async canAdd(moduleName, modulePath) {
    const linkPath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const [stats, currentTarget] = await genAllNull(lstat(linkPath), (0, _fsUtils.readSymlinkTarget)(linkPath));

    if (stats && !stats.isSymbolicLink()) {
      return `${moduleName} already exists and is not a symlink`;
    }

    if (currentTarget && currentTarget !== modulePath) {
      return `${moduleName} is already linked to ${currentTarget}`;
    }

    const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
    if (moduleContainsFolders) {
      const moduleParts = moduleName.split(MODULE_SEPERATOR);
      const folderParts = moduleParts.slice(0, -1);

      const allPartsAreFolders = await everyAsync(folderParts, async (current, index) => {
        const folders = folderParts.slice(0, index + 1);
        const folderPath = _path2.default.resolve(this.nodeModulesPath, ...folders);
        const [folderExists, folderStats] = await genAllNull((0, _fsUtils.exists)(folderPath), lstat(folderPath));

        if (!folderExists || folderStats && folderStats.isDirectory()) return true;

        return false;
      }, '');

      if (!allPartsAreFolders) {
        return `Some parts of ${moduleName} already exist and are not directories`;
      }
    }

    return true;
  }

  async canRemove(moduleName) {
    const modulePath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const [fileExists, isSymLink] = await genAllNull((0, _fsUtils.exists)(modulePath), isSymbolicLink(modulePath));
    return !fileExists || !!isSymLink;
  }

  async add(moduleName, modulePath) {
    const linkPath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const [canAdd, existingTarget] = await genAllNull(this.canAdd(moduleName, modulePath), (0, _fsUtils.readSymlinkTarget)(linkPath));

    if (existingTarget && existingTarget === modulePath) return;
    if (!canAdd) {
      throw new Error(`can not link module ${moduleName} to ${modulePath}`);
    }

    const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
    if (moduleContainsFolders) {
      const moduleParts = moduleName.split(MODULE_SEPERATOR);
      const folderParts = moduleParts.slice(0, -1);
      const folder = _path2.default.resolve(this.nodeModulesPath, ...folderParts);

      await mkdirp(folder);
    }

    await (0, _fsUtils.linkFile)(modulePath, linkPath);
  }

  async removeModule(moduleName) {
    const canRemoveModule = await this.canRemove(moduleName);

    if (!canRemoveModule) {
      throw new Error(`can not unlink module ${moduleName}`);
    }

    const linkPath = _path2.default.resolve(this.nodeModulesPath, moduleName);
    const fileExists = await (0, _fsUtils.exists)(linkPath);

    if (fileExists) {
      await unlink(linkPath);

      const moduleContainsFolders = moduleName.indexOf(MODULE_SEPERATOR) >= 0;
      if (moduleContainsFolders) {
        const moduleParts = moduleName.split(MODULE_SEPERATOR);
        const folderParts = moduleParts.slice(0, -1);

        for (let i = folderParts.length - 1; i >= 0; i--) {
          const dirPath = _path2.default.resolve(this.nodeModulesPath, ...folderParts.slice(0, i + 1));
          const isEmpty = await dirIsEmpty(dirPath);

          if (isEmpty) {
            await rmdir(dirPath);
          }
        }
      }
    }
  }
};
exports.default = FileLinker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWxpbmtlci5qcyJdLCJuYW1lcyI6WyJldmVyeSIsImV2ZXJ5QXN5bmMiLCJsc3RhdCIsIm1rZGlycCIsInVubGluayIsImRpcklzRW1wdHkiLCJybWRpciIsImdlbiIsImdlbkFsbE51bGwiLCJNT0RVTEVfU0VQRVJBVE9SIiwiaXNTeW1ib2xpY0xpbmsiLCJtb2R1bGVQYXRoIiwiZXJyIiwic3RhdCIsIkZpbGVMaW5rZXIiLCJjb25zdHJ1Y3RvciIsInByb2plY3RSb290Iiwibm9kZU1vZHVsZXNQYXRoIiwicmVzb2x2ZSIsImNhbkFkZCIsIm1vZHVsZU5hbWUiLCJsaW5rUGF0aCIsInN0YXRzIiwiY3VycmVudFRhcmdldCIsIm1vZHVsZUNvbnRhaW5zRm9sZGVycyIsImluZGV4T2YiLCJtb2R1bGVQYXJ0cyIsInNwbGl0IiwiZm9sZGVyUGFydHMiLCJzbGljZSIsImFsbFBhcnRzQXJlRm9sZGVycyIsImN1cnJlbnQiLCJpbmRleCIsImZvbGRlcnMiLCJmb2xkZXJQYXRoIiwiZm9sZGVyRXhpc3RzIiwiZm9sZGVyU3RhdHMiLCJpc0RpcmVjdG9yeSIsImNhblJlbW92ZSIsImZpbGVFeGlzdHMiLCJpc1N5bUxpbmsiLCJhZGQiLCJleGlzdGluZ1RhcmdldCIsIkVycm9yIiwiZm9sZGVyIiwicmVtb3ZlTW9kdWxlIiwiY2FuUmVtb3ZlTW9kdWxlIiwiaSIsImxlbmd0aCIsImRpclBhdGgiLCJpc0VtcHR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFQTs7OztBQUVBOztBQUNBOzs7O0FBS0EsTUFBTSxFQUFFQSxPQUFPQyxVQUFULDBCQUFOOztBQUNBLE1BQU0sRUFBRUMsS0FBRixFQUFTQyxNQUFULEVBQWlCQyxNQUFqQixFQUF5QkMsVUFBekIsRUFBcUNDLEtBQXJDLHVCQUFOO0FBQ0EsTUFBTSxFQUFFQyxHQUFGLEVBQU9DLFVBQVAsd0JBQU47O0FBRUEsTUFBTUMsbUJBQW1CLEdBQXpCOztBQUVBLGVBQWVDLGNBQWYsQ0FBOEJDLFVBQTlCLEVBQTJFO0FBQ3pFLFFBQU0sQ0FBQ0MsR0FBRCxFQUFNQyxJQUFOLElBQWMsTUFBTU4sSUFBSUwsTUFBTVMsVUFBTixDQUFKLENBQTFCOztBQUVBLE1BQUlDLE9BQU8sQ0FBQ0MsSUFBWixFQUFrQixPQUFPLEtBQVA7O0FBRWxCLFNBQU9BLEtBQUtILGNBQUwsRUFBUDtBQUNEOztJQUVvQkksVSxHQUFOLE1BQU1BLFVBQU4sQ0FBdUM7O0FBSXBEQyxjQUFZQyxXQUFaLEVBQXdDO0FBQ3RDLFNBQUtBLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QixlQUFLQyxPQUFMLENBQWFGLFdBQWIsRUFBMEIsY0FBMUIsQ0FBdkI7QUFDRDs7QUFFRCxRQUFNRyxNQUFOLENBQWFDLFVBQWIsRUFBc0NULFVBQXRDLEVBQXlGO0FBQ3ZGLFVBQU1VLFdBQVcsZUFBS0gsT0FBTCxDQUFhLEtBQUtELGVBQWxCLEVBQW1DRyxVQUFuQyxDQUFqQjtBQUNBLFVBQU0sQ0FBQ0UsS0FBRCxFQUFRQyxhQUFSLElBQXlCLE1BQU1mLFdBQVdOLE1BQU1tQixRQUFOLENBQVgsRUFBNEIsZ0NBQWtCQSxRQUFsQixDQUE1QixDQUFyQzs7QUFFQSxRQUFJQyxTQUFTLENBQUNBLE1BQU1aLGNBQU4sRUFBZCxFQUFzQztBQUNwQyxhQUFRLEdBQUVVLFVBQVcsc0NBQXJCO0FBQ0Q7O0FBRUQsUUFBSUcsaUJBQWlCQSxrQkFBa0JaLFVBQXZDLEVBQW1EO0FBQ2pELGFBQVEsR0FBRVMsVUFBVyx5QkFBd0JHLGFBQWMsRUFBM0Q7QUFDRDs7QUFFRCxVQUFNQyx3QkFBd0JKLFdBQVdLLE9BQVgsQ0FBbUJoQixnQkFBbkIsS0FBd0MsQ0FBdEU7QUFDQSxRQUFJZSxxQkFBSixFQUEyQjtBQUN6QixZQUFNRSxjQUFjTixXQUFXTyxLQUFYLENBQWlCbEIsZ0JBQWpCLENBQXBCO0FBQ0EsWUFBTW1CLGNBQWNGLFlBQVlHLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBQyxDQUF0QixDQUFwQjs7QUFFQSxZQUFNQyxxQkFBcUIsTUFBTTdCLFdBQy9CMkIsV0FEK0IsRUFFL0IsT0FBT0csT0FBUCxFQUFnQkMsS0FBaEIsS0FBMEI7QUFDeEIsY0FBTUMsVUFBVUwsWUFBWUMsS0FBWixDQUFrQixDQUFsQixFQUFxQkcsUUFBUSxDQUE3QixDQUFoQjtBQUNBLGNBQU1FLGFBQWEsZUFBS2hCLE9BQUwsQ0FBYSxLQUFLRCxlQUFsQixFQUFtQyxHQUFHZ0IsT0FBdEMsQ0FBbkI7QUFDQSxjQUFNLENBQUNFLFlBQUQsRUFBZUMsV0FBZixJQUE4QixNQUFNNUIsV0FBVyxxQkFBTzBCLFVBQVAsQ0FBWCxFQUErQmhDLE1BQU1nQyxVQUFOLENBQS9CLENBQTFDOztBQUVBLFlBQUksQ0FBQ0MsWUFBRCxJQUFrQkMsZUFBZUEsWUFBWUMsV0FBWixFQUFyQyxFQUFpRSxPQUFPLElBQVA7O0FBRWpFLGVBQU8sS0FBUDtBQUNELE9BVjhCLEVBVy9CLEVBWCtCLENBQWpDOztBQWNBLFVBQUksQ0FBQ1Asa0JBQUwsRUFBeUI7QUFDdkIsZUFBUSxpQkFBZ0JWLFVBQVcsd0NBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNa0IsU0FBTixDQUFnQmxCLFVBQWhCLEVBQTJEO0FBQ3pELFVBQU1ULGFBQWEsZUFBS08sT0FBTCxDQUFhLEtBQUtELGVBQWxCLEVBQW1DRyxVQUFuQyxDQUFuQjtBQUNBLFVBQU0sQ0FBQ21CLFVBQUQsRUFBYUMsU0FBYixJQUEwQixNQUFNaEMsV0FBVyxxQkFBT0csVUFBUCxDQUFYLEVBQStCRCxlQUFlQyxVQUFmLENBQS9CLENBQXRDO0FBQ0EsV0FBTyxDQUFDNEIsVUFBRCxJQUFlLENBQUMsQ0FBQ0MsU0FBeEI7QUFDRDs7QUFFRCxRQUFNQyxHQUFOLENBQVVyQixVQUFWLEVBQW1DVCxVQUFuQyxFQUE4RDtBQUM1RCxVQUFNVSxXQUFXLGVBQUtILE9BQUwsQ0FBYSxLQUFLRCxlQUFsQixFQUFtQ0csVUFBbkMsQ0FBakI7QUFDQSxVQUFNLENBQUNELE1BQUQsRUFBU3VCLGNBQVQsSUFBMkIsTUFBTWxDLFdBQVcsS0FBS1csTUFBTCxDQUFZQyxVQUFaLEVBQXdCVCxVQUF4QixDQUFYLEVBQWdELGdDQUFrQlUsUUFBbEIsQ0FBaEQsQ0FBdkM7O0FBRUEsUUFBSXFCLGtCQUFrQkEsbUJBQW1CL0IsVUFBekMsRUFBcUQ7QUFDckQsUUFBSSxDQUFDUSxNQUFMLEVBQWE7QUFDWCxZQUFNLElBQUl3QixLQUFKLENBQVcsdUJBQXNCdkIsVUFBVyxPQUFNVCxVQUFXLEVBQTdELENBQU47QUFDRDs7QUFFRCxVQUFNYSx3QkFBd0JKLFdBQVdLLE9BQVgsQ0FBbUJoQixnQkFBbkIsS0FBd0MsQ0FBdEU7QUFDQSxRQUFJZSxxQkFBSixFQUEyQjtBQUN6QixZQUFNRSxjQUFjTixXQUFXTyxLQUFYLENBQWlCbEIsZ0JBQWpCLENBQXBCO0FBQ0EsWUFBTW1CLGNBQWNGLFlBQVlHLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBQyxDQUF0QixDQUFwQjtBQUNBLFlBQU1lLFNBQVMsZUFBSzFCLE9BQUwsQ0FBYSxLQUFLRCxlQUFsQixFQUFtQyxHQUFHVyxXQUF0QyxDQUFmOztBQUVBLFlBQU16QixPQUFPeUMsTUFBUCxDQUFOO0FBQ0Q7O0FBRUQsVUFBTSx1QkFBU2pDLFVBQVQsRUFBcUJVLFFBQXJCLENBQU47QUFDRDs7QUFFRCxRQUFNd0IsWUFBTixDQUFtQnpCLFVBQW5CLEVBQTRDO0FBQzFDLFVBQU0wQixrQkFBa0IsTUFBTSxLQUFLUixTQUFMLENBQWVsQixVQUFmLENBQTlCOztBQUVBLFFBQUksQ0FBQzBCLGVBQUwsRUFBc0I7QUFDcEIsWUFBTSxJQUFJSCxLQUFKLENBQVcseUJBQXdCdkIsVUFBVyxFQUE5QyxDQUFOO0FBQ0Q7O0FBRUQsVUFBTUMsV0FBVyxlQUFLSCxPQUFMLENBQWEsS0FBS0QsZUFBbEIsRUFBbUNHLFVBQW5DLENBQWpCO0FBQ0EsVUFBTW1CLGFBQWEsTUFBTSxxQkFBT2xCLFFBQVAsQ0FBekI7O0FBRUEsUUFBSWtCLFVBQUosRUFBZ0I7QUFDZCxZQUFNbkMsT0FBT2lCLFFBQVAsQ0FBTjs7QUFFQSxZQUFNRyx3QkFBd0JKLFdBQVdLLE9BQVgsQ0FBbUJoQixnQkFBbkIsS0FBd0MsQ0FBdEU7QUFDQSxVQUFJZSxxQkFBSixFQUEyQjtBQUN6QixjQUFNRSxjQUFjTixXQUFXTyxLQUFYLENBQWlCbEIsZ0JBQWpCLENBQXBCO0FBQ0EsY0FBTW1CLGNBQWNGLFlBQVlHLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBQyxDQUF0QixDQUFwQjs7QUFFQSxhQUFLLElBQUlrQixJQUFJbkIsWUFBWW9CLE1BQVosR0FBcUIsQ0FBbEMsRUFBcUNELEtBQUssQ0FBMUMsRUFBNkNBLEdBQTdDLEVBQWtEO0FBQ2hELGdCQUFNRSxVQUFVLGVBQUsvQixPQUFMLENBQWEsS0FBS0QsZUFBbEIsRUFBbUMsR0FBR1csWUFBWUMsS0FBWixDQUFrQixDQUFsQixFQUFxQmtCLElBQUksQ0FBekIsQ0FBdEMsQ0FBaEI7QUFDQSxnQkFBTUcsVUFBVSxNQUFNN0MsV0FBVzRDLE9BQVgsQ0FBdEI7O0FBRUEsY0FBSUMsT0FBSixFQUFhO0FBQ1gsa0JBQU01QyxNQUFNMkMsT0FBTixDQUFOO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjtBQXZHbUQsQztrQkFBakNuQyxVIiwiZmlsZSI6ImZpbGUtbGlua2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IGFycmF5QXN5bmMsIGZzQXN5bmMsIGdlbkF3YWl0IH0gZnJvbSAnbm9kZS11dGlscyc7XG5pbXBvcnQgeyBleGlzdHMsIGxpbmtGaWxlLCByZWFkU3ltbGlua1RhcmdldCB9IGZyb20gJy4vZnMtdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7IElNb2R1bGVNYXAgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHR5cGUgeyB0QWJzb2x1dGVQYXRoLCB0TW9kdWxlTmFtZSB9IGZyb20gJ2Zsb3ctdHlwZXMnO1xuXG5jb25zdCB7IGV2ZXJ5OiBldmVyeUFzeW5jIH0gPSBhcnJheUFzeW5jO1xuY29uc3QgeyBsc3RhdCwgbWtkaXJwLCB1bmxpbmssIGRpcklzRW1wdHksIHJtZGlyIH0gPSBmc0FzeW5jO1xuY29uc3QgeyBnZW4sIGdlbkFsbE51bGwgfSA9IGdlbkF3YWl0O1xuXG5jb25zdCBNT0RVTEVfU0VQRVJBVE9SID0gJy8nO1xuXG5hc3luYyBmdW5jdGlvbiBpc1N5bWJvbGljTGluayhtb2R1bGVQYXRoOiB0QWJzb2x1dGVQYXRoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IFtlcnIsIHN0YXRdID0gYXdhaXQgZ2VuKGxzdGF0KG1vZHVsZVBhdGgpKTtcblxuICBpZiAoZXJyIHx8ICFzdGF0KSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHN0YXQuaXNTeW1ib2xpY0xpbmsoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUxpbmtlciBpbXBsZW1lbnRzIElNb2R1bGVNYXAge1xuICBwcm9qZWN0Um9vdDogdEFic29sdXRlUGF0aDtcbiAgbm9kZU1vZHVsZXNQYXRoOiB0QWJzb2x1dGVQYXRoO1xuXG4gIGNvbnN0cnVjdG9yKHByb2plY3RSb290OiB0QWJzb2x1dGVQYXRoKSB7XG4gICAgdGhpcy5wcm9qZWN0Um9vdCA9IHByb2plY3RSb290O1xuICAgIHRoaXMubm9kZU1vZHVsZXNQYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RSb290LCAnbm9kZV9tb2R1bGVzJyk7XG4gIH1cblxuICBhc3luYyBjYW5BZGQobW9kdWxlTmFtZTogdE1vZHVsZU5hbWUsIG1vZHVsZVBhdGg6IHRBYnNvbHV0ZVBhdGgpOiBQcm9taXNlPHRydWUgfCBzdHJpbmc+IHtcbiAgICBjb25zdCBsaW5rUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgbW9kdWxlTmFtZSk7XG4gICAgY29uc3QgW3N0YXRzLCBjdXJyZW50VGFyZ2V0XSA9IGF3YWl0IGdlbkFsbE51bGwobHN0YXQobGlua1BhdGgpLCByZWFkU3ltbGlua1RhcmdldChsaW5rUGF0aCkpO1xuXG4gICAgaWYgKHN0YXRzICYmICFzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICByZXR1cm4gYCR7bW9kdWxlTmFtZX0gYWxyZWFkeSBleGlzdHMgYW5kIGlzIG5vdCBhIHN5bWxpbmtgO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIGN1cnJlbnRUYXJnZXQgIT09IG1vZHVsZVBhdGgpIHtcbiAgICAgIHJldHVybiBgJHttb2R1bGVOYW1lfSBpcyBhbHJlYWR5IGxpbmtlZCB0byAke2N1cnJlbnRUYXJnZXR9YDtcbiAgICB9XG5cbiAgICBjb25zdCBtb2R1bGVDb250YWluc0ZvbGRlcnMgPSBtb2R1bGVOYW1lLmluZGV4T2YoTU9EVUxFX1NFUEVSQVRPUikgPj0gMDtcbiAgICBpZiAobW9kdWxlQ29udGFpbnNGb2xkZXJzKSB7XG4gICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IG1vZHVsZU5hbWUuc3BsaXQoTU9EVUxFX1NFUEVSQVRPUik7XG4gICAgICBjb25zdCBmb2xkZXJQYXJ0cyA9IG1vZHVsZVBhcnRzLnNsaWNlKDAsIC0xKTtcblxuICAgICAgY29uc3QgYWxsUGFydHNBcmVGb2xkZXJzID0gYXdhaXQgZXZlcnlBc3luYyhcbiAgICAgICAgZm9sZGVyUGFydHMsXG4gICAgICAgIGFzeW5jIChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvbGRlcnMgPSBmb2xkZXJQYXJ0cy5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5ub2RlTW9kdWxlc1BhdGgsIC4uLmZvbGRlcnMpO1xuICAgICAgICAgIGNvbnN0IFtmb2xkZXJFeGlzdHMsIGZvbGRlclN0YXRzXSA9IGF3YWl0IGdlbkFsbE51bGwoZXhpc3RzKGZvbGRlclBhdGgpLCBsc3RhdChmb2xkZXJQYXRoKSk7XG5cbiAgICAgICAgICBpZiAoIWZvbGRlckV4aXN0cyB8fCAoZm9sZGVyU3RhdHMgJiYgZm9sZGVyU3RhdHMuaXNEaXJlY3RvcnkoKSkpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAnJyxcbiAgICAgICk7XG5cbiAgICAgIGlmICghYWxsUGFydHNBcmVGb2xkZXJzKSB7XG4gICAgICAgIHJldHVybiBgU29tZSBwYXJ0cyBvZiAke21vZHVsZU5hbWV9IGFscmVhZHkgZXhpc3QgYW5kIGFyZSBub3QgZGlyZWN0b3JpZXNgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgY2FuUmVtb3ZlKG1vZHVsZU5hbWU6IHRNb2R1bGVOYW1lKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgbW9kdWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgbW9kdWxlTmFtZSk7XG4gICAgY29uc3QgW2ZpbGVFeGlzdHMsIGlzU3ltTGlua10gPSBhd2FpdCBnZW5BbGxOdWxsKGV4aXN0cyhtb2R1bGVQYXRoKSwgaXNTeW1ib2xpY0xpbmsobW9kdWxlUGF0aCkpO1xuICAgIHJldHVybiAhZmlsZUV4aXN0cyB8fCAhIWlzU3ltTGluaztcbiAgfVxuXG4gIGFzeW5jIGFkZChtb2R1bGVOYW1lOiB0TW9kdWxlTmFtZSwgbW9kdWxlUGF0aDogdEFic29sdXRlUGF0aCkge1xuICAgIGNvbnN0IGxpbmtQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMubm9kZU1vZHVsZXNQYXRoLCBtb2R1bGVOYW1lKTtcbiAgICBjb25zdCBbY2FuQWRkLCBleGlzdGluZ1RhcmdldF0gPSBhd2FpdCBnZW5BbGxOdWxsKHRoaXMuY2FuQWRkKG1vZHVsZU5hbWUsIG1vZHVsZVBhdGgpLCByZWFkU3ltbGlua1RhcmdldChsaW5rUGF0aCkpO1xuXG4gICAgaWYgKGV4aXN0aW5nVGFyZ2V0ICYmIGV4aXN0aW5nVGFyZ2V0ID09PSBtb2R1bGVQYXRoKSByZXR1cm47XG4gICAgaWYgKCFjYW5BZGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2FuIG5vdCBsaW5rIG1vZHVsZSAke21vZHVsZU5hbWV9IHRvICR7bW9kdWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2R1bGVDb250YWluc0ZvbGRlcnMgPSBtb2R1bGVOYW1lLmluZGV4T2YoTU9EVUxFX1NFUEVSQVRPUikgPj0gMDtcbiAgICBpZiAobW9kdWxlQ29udGFpbnNGb2xkZXJzKSB7XG4gICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IG1vZHVsZU5hbWUuc3BsaXQoTU9EVUxFX1NFUEVSQVRPUik7XG4gICAgICBjb25zdCBmb2xkZXJQYXJ0cyA9IG1vZHVsZVBhcnRzLnNsaWNlKDAsIC0xKTtcbiAgICAgIGNvbnN0IGZvbGRlciA9IHBhdGgucmVzb2x2ZSh0aGlzLm5vZGVNb2R1bGVzUGF0aCwgLi4uZm9sZGVyUGFydHMpO1xuXG4gICAgICBhd2FpdCBta2RpcnAoZm9sZGVyKTtcbiAgICB9XG5cbiAgICBhd2FpdCBsaW5rRmlsZShtb2R1bGVQYXRoLCBsaW5rUGF0aCk7XG4gIH1cblxuICBhc3luYyByZW1vdmVNb2R1bGUobW9kdWxlTmFtZTogdE1vZHVsZU5hbWUpIHtcbiAgICBjb25zdCBjYW5SZW1vdmVNb2R1bGUgPSBhd2FpdCB0aGlzLmNhblJlbW92ZShtb2R1bGVOYW1lKTtcblxuICAgIGlmICghY2FuUmVtb3ZlTW9kdWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbiBub3QgdW5saW5rIG1vZHVsZSAke21vZHVsZU5hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlua1BhdGggPSBwYXRoLnJlc29sdmUodGhpcy5ub2RlTW9kdWxlc1BhdGgsIG1vZHVsZU5hbWUpO1xuICAgIGNvbnN0IGZpbGVFeGlzdHMgPSBhd2FpdCBleGlzdHMobGlua1BhdGgpO1xuXG4gICAgaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgIGF3YWl0IHVubGluayhsaW5rUGF0aCk7XG5cbiAgICAgIGNvbnN0IG1vZHVsZUNvbnRhaW5zRm9sZGVycyA9IG1vZHVsZU5hbWUuaW5kZXhPZihNT0RVTEVfU0VQRVJBVE9SKSA+PSAwO1xuICAgICAgaWYgKG1vZHVsZUNvbnRhaW5zRm9sZGVycykge1xuICAgICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IG1vZHVsZU5hbWUuc3BsaXQoTU9EVUxFX1NFUEVSQVRPUik7XG4gICAgICAgIGNvbnN0IGZvbGRlclBhcnRzID0gbW9kdWxlUGFydHMuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBmb2xkZXJQYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5ub2RlTW9kdWxlc1BhdGgsIC4uLmZvbGRlclBhcnRzLnNsaWNlKDAsIGkgKyAxKSk7XG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGF3YWl0IGRpcklzRW1wdHkoZGlyUGF0aCk7XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgYXdhaXQgcm1kaXIoZGlyUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=